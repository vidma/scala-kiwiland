import kwl.utils.SimpleUpdatableMinQueue
import org.scalacheck.Properties
import org.scalacheck.Prop.forAll
import org.scalacheck.Gen
import org.scalacheck.Gen._
import org.scalacheck.Arbitrary
import scala.collection.mutable

/**
 * Using "random" inputs  generated by scalacheck check that:
 * 1. multiple popMin returns items in the sorted order
 * 2. with updates (decreaseKey), queue still work as expected (like 1)
 */
object CheckUpdatableMinQueue extends Properties("UpdatableMinQueue") {
  // type params used for testing
  type V = Char
  type K = Long
  // type aliases
  type QItem = (K, V) // (priority, entry)
  type QItems = List[QItem]
  type QUpdates = (Array[QItem], List[(Int, K)])
  type Queue = SimpleUpdatableMinQueue[Long, V]

  // default sorting order
  implicit val ord = Ordering.by((x: QItem) => x._1)

  /** given arbitrary items to add to a queue, popMin returns them in sorted order? */
  property("FindMinReturnSorted") = forAll { (arb_items: QItems) =>
    val q = new Queue()
    arb_items foreach (q += _)
    // check that multiple popMin result in a sorted list
    compareQueues(sortedPopMin(q), arb_items.sorted)
  }

  /** after performing arbitrary list of updates, queue still works as expected? **/
  property("UpdateWorks") = forAll { (updates: QUpdates) =>
    val (arb_items, arb_updates) = updates
    val q = new Queue()
    arb_items foreach (q += _)
    // update some priorities
    for ((idx, new_key) <- arb_updates;
         id = arb_items(idx)._2) {
      q.updateKey(new_key, id) // update the queue
      arb_items(idx) = (new_key, id) // update the list
    }
    // check that the updated lists still match
    compareQueues(sortedPopMin(q), arb_items.sorted.toList)
  }

  /** obtain a sorted list of queue items by repeatedly calling popMin */
  protected def sortedPopMin(q: Queue): QItems = {
    val sorted = mutable.MutableList.empty[QItem]
    while (!q.isEmpty)
      sorted += q.popMin
    sorted.toList
  }

  /** compare two lists of sorted queue items */
  protected def compareQueues(q1: QItems, q2: QItems): Boolean = {
    def get_key(x: QItem) = x._1
    def groupByWeight(q: QItems) = q.groupBy(get_key).mapValues(Set.empty ++ _.map(_._2))

    // check if the keys are in the right (sorted) order
    val equals = q1.map(get_key) == q2.map(get_key)
    // check that each key bucket has same values
    val matches = groupByWeight(q1) == groupByWeight(q2)
    val ok = equals && matches
    if (!ok) {
      println("Not equal: " + q1 + " and " + q2)
    }
    ok
  }

  /**
   * generator of arbitrary params to propUpdateWorks
   * (initial Queue; indexes to be updated and the new priorities)
   */
  protected def genUpdatesList: Gen[QUpdates] = for {
    queue <- genPriorityQ
    indexes <- listOf(choose(0, queue.length - 1)) // index in the queue
    new_keys <- listOfN(indexes.length, genKey)
  } yield (queue.toArray, indexes zip new_keys)

  /** generator of an Arbitrary Priority Queue i.e. List[(Char, Int)] */
  protected def genPriorityQ: Gen[QItems] = for {
    chars <- listOf(alphaUpperChar) if chars.length > 0
    keys <- listOfN(chars.length, genKey)
  } yield keys zip chars.distinct

  protected def genKey: Gen[K] = choose[K](1, 1000)

  /* define implicit generators */
  implicit lazy val arbQueueUpdates: Arbitrary[QUpdates] = Arbitrary(genUpdatesList)
  implicit lazy val arbPriorityQ: Arbitrary[QItems] = Arbitrary(genPriorityQ)

}